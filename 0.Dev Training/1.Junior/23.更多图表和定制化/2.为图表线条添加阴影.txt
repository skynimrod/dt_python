. 为了区分图表中的某一线条, 或者仅仅为了保持包含图表在内的所有表格的总体风格, 优势需要为图表线条(或者直方图)添加阴影效果.

. 准备工作

      为了向图表中的线条或者矩形条 添加阴影, 需要使用matplotlib 内置的 transformation 框架, 其位于 matplotlib.transforms 模块中.

      Transformations 知道如何将给定的坐标从其坐标系 转换到 显示坐标系中, 它们也知道如何将坐标从显示坐标系 转换到 它们自己的坐标系中.

   ---------------------------------------------
     坐标系  |     Transformation 对象   |     描述
   ----------------------------------------------------
    Data       Axes.transData              表示用户的数据坐标系

    Axes       Axes.transAxes              表示Axes 坐标系, 其中(0,0)表示轴的左下角, (1,1)表示轴的右上角

    Figure     Figure.transFigure          是Figure 坐标系, 其中(0,0)表示图标的左下角,(1,1)表示图表的右上角

    Display    None                        表示用户视窗的像素坐标系, 其中(0,0)表示视窗的左下角, (width,height) 元组表示显
                                           示界面的右上角. 这里的width 和 height 都是以像素为单位的.
    --------------------------------------------------------------------------------------------------

    注意, 在 Transformation 对象列中, 视窗坐标系是没有值的. 这是因为默认的坐标系就是Display 坐标系, 坐标 总是在视窗坐标系下并以像素为单位. 但这没有太大的用处, 因为大多数情况下我们想把坐标归一化到 Figure、Axes 或者 一个Data 坐标系中.

    这个框架能让我们把现有对象转化成一个偏移对象, 也就是说, 把对象放置到偏离原来对象一段距离的地方.

. 工作原理

      我们从后部分代码 if __name__ 检查语句之后开始阅读. 首先通过setup() 创建 figure 和 axes. 然后, 得到一个信号(或者说生成一个正弦波数据)。 在plot_signal() 方法中绘制出基本的信号图. 最后, 进行阴影坐标转换并在make_shadow() 方法中绘制出阴影.

      使用偏移效果创建一个偏移对象, 把阴影放置在原始对象之下并偏移几个点的距离.

      原始对象是一个简单的正弦波, 用标准的plot() 方法进行绘制.

      matplotlib 包含一个transformations helper ---- matplotlib.transforms.ScaledTranslation ---- 来添加偏移转换

      dx 和 dy 的值以点为单位. 因为点是 1/72 英寸, 向右移动偏移对象2pt, 向下偏移移动对象2pt.   

      可以使用matplotlib.transforms.ScaledTransformation( xtr, ytr, scaletr) 方法。 这里, xtr 和 ytr 是转换的偏移量, scaletr 是一个转换可调用对象( callable), 在转换时 和显示之前对 xtr 和 ytr 进行比例调整. 其最常用的情况是从点转换到显示区域，如DPI, 这样偏移始终保持在相同的位置而与实际的输出设备无关(可以是显示器或者打印的材料)。我们使用的可调用对象已经内置在matplotlib 中, 可以从Figure.dpi_scale_trans 得到。

      然后, 用这些数据转换把数据绘制出来.

. 补充说明

      使用transforms 添加阴影只是这个框架的一种但不是最流行的用法. 为了用transformations 框架做更多的事情, 需要了解transformation管道工作原理的详细内容以及有哪些扩展点(继承以及如何继承哪些类). 这非常简单, 因为matplotlib 是开源的, 即使一些代码没有很好的文档, 也可以阅读、使用源码或者做些修改, 进而为matplotlib 总体的质量和可用性做些贡献. 

